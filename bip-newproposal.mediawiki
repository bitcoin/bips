TBD | QES2 | A Hybrid Post-Quantum and Classical Digital Signature Scheme for Bitcoin | [Caleb Lee] director@j1729labs.online, [Justin Park] < justin7361@j1729labs.online>, [Eunice Lee] cuspro0103@j1729labs.online, [Sophia Shim] zypo1015@j1729labs.online | 2025-04-18 | Draft

BIP: Unassigned Title: QES2 - A Hybrid Post-Quantum and Classical
Digital Signature Scheme for Bitcoin Author: [Caleb Lee]
director@j1729labs.online, [Justin Park] < justin7361@j1729labs.online>,
[Eunice Lee] cuspro0103@j1729labs.online, [Sophia Shim]
zypo1015@j1729labs.online Comments-URI:
https://github.com/bitcoin/bips/wiki/Comments:BIP-XXXX Status: Draft
Type: Standards Track Created: 2025-04-18 License: BSD-2-Clause
Requires: 340, 341, 342

Abstract
========

This BIP proposes QES2 (Quantum-Enhanced Signature Scheme), a hybrid
digital signature scheme that creates a cryptographic binding between
post-quantum cryptography (specifically Dilithium) and traditional ECDSA
signatures for Bitcoin transactions. The approach first creates a
Dilithium signature and then uses ECDSA to sign the Dilithium signature
itself, creating a chain of cryptographic trust where the classical
signature verifies the quantum-resistant signature. This approach
provides both quantum resistance and backward compatibility, enabling
Bitcoin to transition gradually to quantum-resistant security while
preserving compatibility with existing infrastructure.

Copyright
=========

This BIP is licensed under the BSD 2-clause license.

Motivation
==========

Bitcoin’s security fundamentally relies on the Elliptic Curve Digital
Signature Algorithm (ECDSA) with the secp256k1 curve. While effective
against classical computing attacks, ECDSA is vulnerable to quantum
computers running Shor’s algorithm, which can solve the discrete
logarithm problem in polynomial time.

As quantum computing advances, this vulnerability poses an existential
threat to Bitcoin’s security model. Recent estimates suggest that
sufficiently powerful quantum computers capable of breaking ECDSA could
be developed within the next decade.

The Bitcoin community faces several challenges when considering a
transition to post-quantum cryptography:

1. Post-quantum signature schemes typically have significantly larger
   key and signature sizes
2. Complete replacement of ECDSA would break compatibility with existing
   wallets and infrastructure
3. The security of newer post-quantum schemes is still being evaluated
   by the cryptographic community
4. A sudden switch would require extensive coordination across the
   entire ecosystem

This BIP proposes QES2 as a balanced solution that:

1. Maintains compatibility with existing Bitcoin infrastructure
2. Adds quantum resistance through a lattice-based signature scheme
   (Dilithium)
3. Creates a cryptographic binding between PQC signatures and ECDSA
   signatures
4. Allows for a gradual, opt-in transition to quantum-resistant security
5. Creates a safety net against future quantum computing threats

Specification
=============

Overview
--------

QES2 combines the Dilithium post-quantum signature scheme with the
classical ECDSA signature scheme currently used in Bitcoin. The key
innovation is that QES2 doesn’t just use both signature schemes in
parallel but creates a cryptographic binding between them. First, the
Dilithium signature is generated for the transaction digest, then the
ECDSA signature signs the Dilithium signature itself. This binding
ensures that the ECDSA signature validates the integrity of the
quantum-resistant signature.

The QES2 signature process can be represented as:

:math:``\text{Sign}_{QES2} = \text{Sign}_{ECDSA}(\text{Sign}_{PQC}(\text{message}))``

And the verification process:

:math:``\text{Verify}_{QES2} = \text{Verify}_{ECDSA}(\sigma_{PQ}) \land \text{Verify}_{PQC}(\text{message})``

This creates a chained trust model where breaking the scheme would
require breaking both the quantum-resistant signature and the classical
signature.

Mathematical Notation and Parameters
------------------------------------

Let us define the following notation:

- :math:``m``: The message to be signed (transaction digest)
- :math:``sk_{PQ}``: Dilithium private key
- :math:``pk_{PQ}``: Dilithium public key
- :math:``sk_{EC}``: ECDSA private key
- :math:``pk_{EC}``: ECDSA public key
- :math:``\sigma_{PQ}``: Dilithium signature on the message
- :math:``\sigma_{EC}``: ECDSA signature on the Dilithium signature
- :math:``H``: SHA-256 hash function
- :math:``\mathcal{S}_{PQ}``: Dilithium signing algorithm
- :math:``\mathcal{V}_{PQ}``: Dilithium verification algorithm
- :math:``\mathcal{S}_{EC}``: ECDSA signing algorithm
- :math:``\mathcal{V}_{EC}``: ECDSA verification algorithm

Dilithium Parameters ~~~~~~~~~~~~~~~~~~~

The Dilithium instantiation uses the following parameters:

- Security level: NIST security level 3 (equivalent to AES-192)
- Dimension :math:``n``: 256
- Modulus :math:``q``: 8380417
- Weight of challenge :math:``\gamma_1``: 60
- Weight of secret :math:``\gamma_2``: :math:``(q-1)/16``
- Number of iterations :math:``\kappa``: 5
- Public key size: 1,952 bytes
- Private key size: 4,000 bytes
- Signature size: 2,701 bytes

ECDSA Parameters ~~~~~~~~~~~~~~~

The ECDSA implementation uses the following parameters:

- Curve: secp256k1
- Field size: 256 bits
- Public key size: 33 bytes (compressed)
- Signature size: ~72 bytes (with sighash flag)

Script Types and Address Format
-------------------------------

This BIP introduces a new script template::

::

   <pq_signature_push> <ecdsa_signature_push> <pubkey_push> OP_QES2_CHECKSIG

Where:

- ``<pq_signature_push>`` is the Dilithium signature component on the
  transaction digest
- ``<ecdsa_signature_push>`` is the ECDSA signature on the Dilithium
  signature
- ``<pubkey_push>`` includes both the ECDSA public key and Dilithium
  public key
- ``OP_QES2_CHECKSIG`` is a new opcode that verifies the entire chained
  signature scheme

New Opcode ~~~~~~~~~~

We introduce a new opcode, tentatively assigned as
``OP_QES2_CHECKSIG (0xba)``, that performs verification of the hybrid
QES2 signature by checking both the ECDSA signature (which validates the
PQC signature) and the Dilithium signature itself.

P2QPK (Pay to QES2 Public Key) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similar to P2PK, but using QES2::

::

   <combined_pubkey> OP_QES2_CHECKSIG

P2QPKH (Pay to QES2 Public Key Hash)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similar to P2PKH, but using a hash of the combined QES2 public key::

::

   OP_DUP OP_HASH160 <qes2_pubkeyhash> OP_EQUALVERIFY OP_QES2_CHECKSIG

P2QSH (Pay to QES2 Script Hash) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Similar to P2SH, but with QES2 signature verification::

::

   OP_HASH160 <qes2_script_hash> OP_EQUAL

Address Format ~~~~~~~~~~~~~

QES2 addresses use a new version byte with a Bech32m encoding::

::

   qp1<bech32m_encoded_program>

Where the version byte indicates the use of QES2 and distinguishes
between P2QPKH and P2QSH formats.

Key Management
--------------

Two approaches for managing QES2 keys:

1. **Deterministic Derivation**

   The Dilithium key pair is deterministically derived from the ECDSA
   private key:

   :math:``sk_{PQ} = \text{HMAC-SHA512}(sk_{EC}, \text{"Bitcoin_Dilithium_Key_Derivation"})``

   From :math:``sk_{PQ}``, we compute:

   :math:``pk_{PQ} = \text{Dilithium.KeyGen}(sk_{PQ})``

2. **Independent Keys**

   The ECDSA and Dilithium key pairs are generated independently and
   bound together in the transaction script.

The combined public key is represented as:

:math:``pk_{combined} = pk_{PQ} \parallel pk_{EC}``

Where :math:``\parallel`` denotes concatenation.

The first approach is recommended for simplicity of wallet
implementation, while the second offers greater flexibility.

Signing Process
---------------

The QES2 signing process consists of the following steps:

1. **Transaction Serialization**

   - Serialize the transaction inputs and outputs according to the
     appropriate sighash algorithm
   - Generate the transaction digest :math:``m = H(H(\text{tx}))`` using
     double SHA-256

2. **Post-Quantum Signature Generation**

   - Generate a Dilithium signature on the transaction digest:

     :math:``\sigma_{PQ} = \mathcal{S}_{PQ}(sk_{PQ}, m)``

3. **Vector Encoding**

   - Flatten the post-quantum signature to obtain a coefficient vector
   - Apply domain-specific encoding to the coefficient vector
   - Apply compression and normalization to produce :math:``\hat{e}``

4. **ECDSA Signature Generation**

   - Generate an ECDSA signature directly on the encoded PQC signature:

     :math:``\sigma_{EC} = \mathcal{S}_{EC}(sk_{EC}, \hat{e})``

   - The ECDSA signature follows the standard Bitcoin format, including
     the appropriate sighash flag

5. **Complete Signature**

   - The final QES2 signature consists of:
     :math:``(\sigma_{PQ}, \sigma_{EC})``

This process can be summarized as:

:math:``\text{Sign}_{QES2}(m) = (\sigma_{PQ}, \sigma_{EC})`` where: -
:math:``\sigma_{PQ} = \mathcal{S}_{PQ}(sk_{PQ}, m)`` -
:math:``\sigma_{EC} = \mathcal{S}_{EC}(sk_{EC}, \hat{e})``

Importantly, the ECDSA signature is not signing the original message but
is signing the PQC signature directly. This creates a cryptographic
binding where the ECDSA signature validates the Dilithium signature.

Verification Procedure
----------------------

The verification of a QES2 signature consists of the following steps:

1. **Transaction Digest Calculation**

   - Calculate the transaction digest :math:``m = H(H(\text{tx}))``
     according to the sighash flags

2. **Vector Decoding**

   - Decode the PQC signature component :math:``\sigma_{PQ}`` to obtain
     :math:``\hat{e}``

3. **ECDSA Signature Verification**

   - Verify the ECDSA signature on the encoded PQC signature:

     :math:``valid_{EC} = \mathcal{V}_{EC}(pk_{EC}, \hat{e}, \sigma_{EC})``

   - This step verifies the integrity of the Dilithium signature

4. **Post-Quantum Signature Verification**

   - Verify the Dilithium signature on the original transaction digest:

     :math:``valid_{PQ} = \mathcal{V}_{PQ}(pk_{PQ}, m, \sigma_{PQ})``

5. **Combined Verification Decision**

   - Accept the QES2 signature as valid if and only if both
     verifications succeed:

     :math:``valid = valid_{EC} \land valid_{PQ}``

The verification process can be summarized as:

:math:``\text{Verify}_{QES2}(m, \sigma_{PQ}, \sigma_{EC}, pk_{PQ}, pk_{EC}) = \mathcal{V}_{EC}(pk_{EC}, \hat{e}, \sigma_{EC}) \land \mathcal{V}_{PQ}(pk_{PQ}, m, \sigma_{PQ})``

This verification procedure ensures that: 1. The transaction has not
been tampered with (verified by Dilithium) 2. The Dilithium signature is
valid for the transaction 3. The ECDSA signature validates the integrity
of the Dilithium signature

The security of this approach stems from the fact that an attacker would
need to forge both signature types or find a way to create a valid ECDSA
signature that endorses a forged Dilithium signature.

Optimizations
-------------

To maintain reasonable validation performance:

1. **Early rejection**: Perform ECDSA verification first and only
   proceed with Dilithium verification if ECDSA passes
2. **Optional verification**: During the initial deployment phase, nodes
   can verify only the ECDSA component
3. **Batch verification**: For multiple signatures in a transaction, use
   batch verification techniques

The early rejection optimization can be formalized as:

.. math::

:raw-latex:`\begin{align}
   valid = 
   \begin{cases}
   \mathcal{V}_{PQ}(pk_{PQ}, m, \sigma_{PQ}) & \text{if } \mathcal{V}_{EC}(pk_{EC}, \hat{e}, \sigma_{EC}) = true \\
   false & \text{otherwise}
   \end{cases}
   \end{align}`

Taproot Compatibility
---------------------

QES2 can be integrated with BIP-340 (Taproot) by:

1. Using the QES2-based signature in place of the Schnorr signature
2. Extending the taproot output to accommodate both ECDSA and Dilithium
   public keys
3. Modifying the key-path spending to use QES2

The taproot Merkle root calculation would be modified to include both
the ECDSA and Dilithium components:

:math:``P = pk_{EC} + \text{hash}_{\text{taptweak}}(pk_{EC} \parallel pk_{PQ} \parallel \text{Merkle root}) \cdot G``

Where :math:``G`` is the generator point of the secp256k1 curve.

Rationale
=========

Hybrid Chained Approach
-----------------------

The hybrid chained approach offers several advantages over a direct
switch to post-quantum cryptography or a simple parallel combination of
signatures:

1. **Enhanced Security**: The binding between signatures means an
   attacker must break both schemes
2. **Cryptographic Binding**: ECDSA signature validates the integrity of
   the Dilithium signature
3. **Compatibility**: Maintains compatibility with existing Bitcoin
   infrastructure
4. **Confidence**: Uses established ECDSA while introducing quantum
   resistance
5. **Efficient Verification**: The ECDSA verification can serve as an
   initial check before more expensive PQC verification

The specific chaining approach (PQC followed by ECDSA signing the PQC
signature) ensures that:

1. The quantum-resistant signature provides the primary security layer
   for the transaction
2. The ECDSA signature provides a binding mechanism that validates the
   PQC signature
3. The combined approach prevents potential isolation attacks against
   either scheme
4. Breaking the scheme would require breaking both the quantum-resistant
   signature and the classical signature, or finding a collision in the
   hash function

Choice of Post-Quantum Algorithm
--------------------------------

Dilithium is selected as the post-quantum component because:

1. It is a finalist in the NIST post-quantum cryptography
   standardization process
2. It offers a reasonable balance between security level, signature
   size, and verification speed
3. It has undergone extensive cryptanalysis
4. Its lattice-based structure allows for potential optimizations in
   verification

The security reduction for Dilithium is based on the hardness of the
Module Learning With Errors (MLWE) and Module Short Integer Solution
(MSIS) problems, which are believed to be resistant to quantum attacks.

Script Capability
-----------------

The introduction of a new opcode provides several benefits:

1. Clean integration into the Bitcoin scripting system
2. Flexibility for future signature scheme upgrades
3. Clear distinction between quantum-resistant and classical addresses
4. Ability to verify the chained signature scheme efficiently

Size and Performance Impact
---------------------------

The QES2 approach introduces additional overhead:

1. **Signature Size**:

   - ECDSA signature: ~72 bytes
   - Dilithium signature: ~2.7 KB
   - Total QES2 size with optimizations: ~2.8 KB

2. **Verification Time**:

   - ECDSA verification: ~0.3ms on standard hardware
   - Dilithium verification: ~1.2ms
   - Combined with optimizations: ~1.5ms

3. **Impact on Block Space**:

   - Increased transaction size by approximately 2.7 KB per input
   - Partially mitigated by optional adoption during transition phase

The efficiency ratio can be expressed as:

:math:``\text{Efficiency} = \frac{\text{Security Benefit}}{\text{Size Overhead}}``

Where the security benefit is measured by the estimated years of
protection against quantum attacks.

Backwards Compatibility
=======================

This BIP maintains backward compatibility through several mechanisms:

1. **Opt-in Deployment**: QES2 addresses are distinct from traditional
   addresses
2. **Traditional Scripts**: Existing P2PKH, P2SH, P2WPKH, and P2WSH
   scripts continue to function normally
3. **Validation Rules**: Nodes that do not implement this BIP will see
   the new scripts as anyone-can-spend outputs
4. **Soft Fork**: This change can be deployed as a soft fork

Deployment
==========

This BIP should be deployed as a soft fork using the standard BIP-9
version bits method:

1. **Bit**: TBD
2. **Start time**: TBD
3. **Timeout**: TBD

The deployment follows a phased approach:

1. **Phase 1 - Optional Implementation**: Support for QES2 exists but is
   not required for consensus
2. **Phase 2 - Activation**: The soft fork activates, and QES2 scripts
   become valid
3. **Phase 3 - Transition**: Users gradually migrate to
   quantum-resistant addresses

Reference Implementation
========================

A reference implementation will be provided in a separate pull request
to the Bitcoin Core repository, including:

1. Implementation of the new opcode
2. Verification logic for the hybrid chained signature scheme
3. Wallet functionality for creating and signing with QES2

The pseudocode for the key signing process is as follows:

::

   function signQES2(message, dilithiumPrivKey, ecdsaPrivKey):
       // First generate the PQC signature on the message
       dilithiumSignature = dilithiumSign(message, dilithiumPrivKey)
       
       // Encode the PQC signature
       encodedPQSig = encodeDilithiumSignature(dilithiumSignature)
       
       // Generate ECDSA signature directly on the encoded PQC signature
       ecdsaSignature = ecdsaSign(encodedPQSig, ecdsaPrivKey)
       
       // Return the complete QES2 signature
       return (dilithiumSignature, ecdsaSignature)

The pseudocode for key verification is as follows:

::

   function verifyQES2Signature(message, dilithiumSignature, ecdsaSignature, dilithiumPubKey, ecdsaPubKey):
       // Encode the PQC signature
       encodedPQSig = encodeDilithiumSignature(dilithiumSignature)
       
       // First verify ECDSA (faster verification)
       // This verifies the integrity of the PQC signature
       if not verifyECDSA(encodedPQSig, ecdsaSignature, ecdsaPubKey):
           return false
       
       // Only verify Dilithium if ECDSA passes
       return verifyDilithium(message, dilithiumSignature, dilithiumPubKey)

Test Vectors
============

Test vectors will include:

1. Sample key pairs (ECDSA and Dilithium)
2. Sample messages and their corresponding QES2 signatures
3. Script validation examples
4. Edge cases for validation

Example Test Vector:

::

   # Test Vector 1
   Message (Transaction Digest): 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef

   # ECDSA Key Pair
   ECDSA Private Key: 0xef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcd
   ECDSA Public Key: 0x02b1e6079a23ab7a7e5a7bc7a1a811a96ef37248143da0c4d35765c25094fcc712

   # Dilithium Key Pair
   Dilithium Private Key: [4000 bytes, hexadecimal]
   Dilithium Public Key: [1952 bytes, hexadecimal]

   # Step 1: Dilithium Signature on Original Message
   Dilithium Signature: [2701 bytes, hexadecimal]

   # Step 2: Encoded Dilithium Signature
   Encoded Signature: [compressed representation]

   # Step 3: ECDSA Signature on Encoded Dilithium Signature
   ECDSA Signature: 0x304402201234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef022012345678901234567890abcdef1234567890abcdef1234567890abcdef12345678

   # Complete QES2 Signature
   QES2 Signature: [Dilithium Signature || ECDSA Signature]

Security Considerations
=======================

Quantum Timeline
----------------

The implementation timeline considers quantum computing development:

1. **Near-term (3-5 years)**: Low quantum threat, preparation phase
2. **Medium-term (5-10 years)**: Growing threat, transition phase
3. **Long-term (10+ years)**: Potential quantum capacity to break ECDSA

The risk assessment formula can be modeled as:

:math:``\text{Risk} = \text{Probability of Attack} \times \text{Impact of Compromise}``

Where the probability increases with quantum computing development, and
the impact depends on the value secured by ECDSA.

Migration Security
------------------

During the transition period:

1. Coins in traditional addresses will become increasingly vulnerable
2. Tools should be provided to securely migrate funds to
   quantum-resistant addresses
3. Community education about quantum security risks becomes critical

The security of funds during migration depends on the following
inequality:

:math:``T_{\text{migration}} < T_{\text{quantum break}}``

Where :math:``T_{\text{migration}}`` is the time required to migrate
funds to quantum-resistant addresses, and
:math:``T_{\text{quantum break}}`` is the time until quantum computers
can break ECDSA.

Implementation Security
-----------------------

Implementers should be aware of:

1. Side-channel resistance in both signature schemes
2. Appropriate entropy for key generation
3. Secure storage of larger keys and signatures
4. Protection against combined cryptographic attacks

The entropy requirements for key generation are:

:math:``\text{Entropy}_{\text{QES2}} \geq \max(\text{Entropy}_{\text{ECDSA}}, \text{Entropy}_{\text{Dilithium}}) \geq 256 \text{ bits}``

Security Proofs
---------------

The security of QES2 relies on the following propositions:

1. **Dilithium Security**: The Dilithium signature is secure against
   quantum adversaries under the hardness assumptions of Module-LWE and
   Module-SIS problems.

2. **ECDSA Security**: While vulnerable to quantum attacks, ECDSA
   remains secure against classical adversaries.

3. **Binding Property**: The ECDSA signature validates the Dilithium
   signature, creating a binding that requires breaking both schemes or
   finding hash collisions to forge.

4. **Hybrid Security Theorem**: If either signature scheme remains
   secure, the combined QES2 signature remains secure. Formally:

   :math:``\text{Adv}_{QES2}(A) \leq \min(\text{Adv}_{ECDSA}(A'), \text{Adv}_{Dilithium}(A''))``

   Where :math:``\text{Adv}_X(A)`` represents the advantage of an
   adversary A against scheme X.

Acknowledgments
===============

This proposal builds on the work of several other BIPs, including
BIP-340, BIP-341, and BIP-342 (Taproot), and incorporates concepts from
ongoing research in post-quantum cryptography for blockchains.

References
==========

1. NIST Post-Quantum Cryptography Standardization Process:
   https://csrc.nist.gov/projects/post-quantum-cryptography
2. Dilithium: CRYSTALS-Dilithium Algorithm Specifications and Supporting
   Documentation (v3.1)
3. BIP-340, BIP-341, BIP-342 (Taproot): https://github.com/bitcoin/bips
4. Bernstein, D.J., et al. “Post-Quantum Cryptography.” Springer, 2009.
5. Ducas, L., et al. “CRYSTALS-Dilithium: A Lattice-Based Digital
   Signature Scheme.” IACR Transactions on Cryptographic Hardware and
   Embedded Systems, 2018.
6. Shor, P.W. “Polynomial-Time Algorithms for Prime Factorization and
   Discrete Logarithms on a Quantum Computer.” SIAM Journal on
   Computing, 1997.
7. Grover, L.K. “A Fast Quantum Mechanical Algorithm for Database
   Search.” Proceedings of the 28th Annual ACM Symposium on Theory of
   Computing, 1996.
8. Bindel, N., et al. “Hybrid Key Encapsulation Mechanisms and
   Authenticated Key Exchange.” Post-Quantum Cryptography, 2019.
9. Crockett, E., et al. “A Note on the Dual-Signature Approach to Key
   Confirmation.” Cryptology ePrint Archive, Report 2021.
