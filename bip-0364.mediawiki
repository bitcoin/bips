<pre>
  BIP: ??? (suggestion: 364) 
  Layer: Consensus (soft fork)
  Title: 64 bit arithmetic operations 
  Author: Chris Stewart <stewart.chris1234@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: ??? 
  Status: Draft 
  Type: Standards Track
  Created: 2023-09-11
  License: PD
</pre>

==Abstract==

This BIP describes a new set of opcodes (OP_ADD64, OP_SUB64, OP_MUL64, OP_DIV64, OP_NEG64, 
OP_LESSTHAN64, OP_LESSTHANOREQUAL64, OP_GREATERTHAN64, OP_GREATERTHANOREQUAL64)
that allows 64 bit signed integer math in the bitcoin protocol.

==Summary==

The arithmetic opcodes (OP_ADD64, OP_SUB64, OP_MUL64, OP_DIV64) behave as follows 

* Fail if less than 2 elements on the stack 
* Fail if the stacks top 2 elements are not exactly 8 bytes 
* If the operation results in an overflow, push false onto the stack 
* If the operation succeeds without overflow, push the result and true onto the stack 
* the nSequence field of the txin is 0xffffffff;

64 bit comparison opcodes (OP_LESSTHAN64, OP_LESSTHANOREQUAL64, OP_GREATERTHAN64, OP_GREATERTHANOREQUAL64)
* Fail if less than 2 elements on the stack 
* Fail if the stacks top 2 elements are not exactly 8 bytes 
* Push the boolean result of the comparison onto the stack

OP_NEG64
* Fail if less than 1 element on the stack 
* Fail if the stacks top is not exactly 8 bytes 
* If the operation results in an overflow (stack top == std::numeric_limits<int64_t>::min()), push false onto the stack 
* Push the result of negating the stack top onto the stack and push true onto the stack

==Motivation==

64 bit arithmetic operations are required to support arithmetic on satoshi values.
Math on satoshis required precision of 51 bits. Many bitcoin protocol proposals - such as covenants -
require Script access to output values. To support the full range of possible output values
we need 64 bit precision.

===OP_INOUT_AMOUNT===

[OP_INOUT_AMOUNT](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019420.html) is 
part of the [OP_TAPLEAFUPDATE_VERIFY](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html) soft fork proposal.
This opcode pushes two values onto the stack, the amount from this
input's utxo, and the amount in the corresponding output, and then expect
anyone using OP_TLUV to use maths operators to verify that funds are being
appropriately retained in the updated scriptPubKey.

Since the value of the utxos can be up to 51 bits in value, we require 64 bit
arithmetic operations.


==Overflows==

When dealing with overflows, we explicitly return the success bit as a CScriptNum at the top of the stack and the result being the second element from the top. If the operation overflows, first the operands are pushed onto the stack followed by success bit. [a_second a_top] overflows, the stack state after the operation is [a_second a_top 0] and if the operation does not overflow, the stack state is [res 1].

This gives the user flexibility to deal if they script to have overflows using OP_IF\OP_ELSE or OP_VERIFY the success bit if they expect that operation would never fail. When defining the opcodes which can fail, we only define the success path, and assume the overflow behavior as stated above.

==Detailed Specification==

Refer to the reference implementation, reproduced below, for the precise
semantics and detailed rationale for those semantics.
    
	case OP_ADD64:
	case OP_SUB64:
	case OP_MUL64:
	case OP_DIV64:
	case OP_LESSTHAN64:
	case OP_LESSTHANOREQUAL64:
	case OP_GREATERTHAN64:
	case OP_GREATERTHANOREQUAL64:
	{
	    // Opcodes only available post tapscript
	    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);

	    if (stack.size() < 2)
		return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);

	    valtype& vcha = stacktop(-2);
	    valtype& vchb = stacktop(-1);
	    if (vchb.size() != 8 || vcha.size() != 8)
		return set_error(serror, SCRIPT_ERR_EXPECTED_8BYTES);

	    int64_t b = read_le8_signed(vchb.data());
	    int64_t a = read_le8_signed(vcha.data());

	    switch(opcode)
	    {
		case OP_ADD64:
		    if ((a > 0 && b > std::numeric_limits<int64_t>::max() - a) ||
		        (a < 0 && b < std::numeric_limits<int64_t>::min() - a))
		        stack.push_back(vchFalse);
		    else {
		        popstack(stack);
		        popstack(stack);
		        push8_le(stack, a + b);
		        stack.push_back(vchTrue);
		    }
		break;
		case OP_SUB64:
		    if ((b > 0 && a < std::numeric_limits<int64_t>::min() + b) ||
		        (b < 0 && a > std::numeric_limits<int64_t>::max() + b))
		        stack.push_back(vchFalse);
		    else {
		        popstack(stack);
		        popstack(stack);
		        push8_le(stack, a - b);
		        stack.push_back(vchTrue);
		    }
		break;
		case OP_MUL64:
		    if ((a > 0 && b > 0 && a > std::numeric_limits<int64_t>::max() / b) ||
		        (a > 0 && b < 0 && b < std::numeric_limits<int64_t>::min() / a) ||
		        (a < 0 && b > 0 && a < std::numeric_limits<int64_t>::min() / b) ||
		        (a < 0 && b < 0 && b < std::numeric_limits<int64_t>::max() / a))
		        stack.push_back(vchFalse);
		    else {
		        popstack(stack);
		        popstack(stack);
		        push8_le(stack, a * b);
		        stack.push_back(vchTrue);
		    }
		break;
		case OP_DIV64:
		{
		    if (b == 0 || (b == -1 && a == std::numeric_limits<int64_t>::min())) { stack.push_back(vchFalse); break; }
		    int64_t r = a % b;
		    int64_t q = a / b;
		    if (r < 0 && b > 0)      { r += b; q-=1;} // ensures that 0<=r<|b|
		    else if (r < 0 && b < 0) { r -= b; q+=1;} // ensures that 0<=r<|b|
		    popstack(stack);
		    popstack(stack);
		    push8_le(stack, r);
		    push8_le(stack, q);
		    stack.push_back(vchTrue);
		}
		break;
		break;
		case OP_LESSTHAN64:            popstack(stack); popstack(stack); stack.push_back( (a <  b) ? vchTrue : vchFalse ); break;
		case OP_LESSTHANOREQUAL64:     popstack(stack); popstack(stack); stack.push_back( (a <= b) ? vchTrue : vchFalse ); break;
		case OP_GREATERTHAN64:         popstack(stack); popstack(stack); stack.push_back( (a >  b) ? vchTrue : vchFalse ); break;
		case OP_GREATERTHANOREQUAL64:  popstack(stack); popstack(stack); stack.push_back( (a >= b) ? vchTrue : vchFalse ); break;
		default:                       assert(!"invalid opcode"); break;
	    }
	}
	break;
	case OP_NEG64:
	{
	    // Opcodes only available post tapscript
	    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);

	    if (stack.size() < 1)
		return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);

	    valtype& vcha = stacktop(-1);
	    if (vcha.size() != 8)
		return set_error(serror, SCRIPT_ERR_EXPECTED_8BYTES);

	    int64_t a = read_le8_signed(vcha.data());
	    if (a == std::numeric_limits<int64_t>::min()) { stack.push_back(vchFalse); break; }

	    popstack(stack);
	    push8_le(stack, -a);
	    stack.push_back(vchTrue);
	}
	break;
    
https://github.com/Christewart/bitcoin/commits/64bit-arith 

==Deployment==

todo

==Credits==

This work is borrowed from work done on the elements project, with implementations done by Sanket Kanjalkar and Andrew Poelstra.

==References==

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019420.html

==Copyright==

This document is placed in the public domain.

