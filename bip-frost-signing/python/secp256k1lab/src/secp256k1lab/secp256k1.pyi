from __future__ import annotations

# mypy treated secp256k1lab.secp256k1 as Any, so callers (see frost_ref/signing.py)
# hit "Returning Any from function declared to return ..." errors. This stub describes adds type defintions for the secp256k1lab APIs used

from typing_extensions import Self


class APrimeFE:
    SIZE: int

    def __init__(self, a: int | Self = 0, b: int | Self = 1) -> None: ...
    def __add__(self, a: int | Self) -> Self: ...
    def __radd__(self, a: int) -> Self: ...

    @classmethod
    def sum(cls, *es: Self) -> Self: ...

    def __sub__(self, a: int | Self) -> Self: ...
    def __rsub__(self, a: int) -> Self: ...
    def __mul__(self, a: int | Self) -> Self: ...
    def __rmul__(self, a: int) -> Self: ...
    def __truediv__(self, a: int | Self) -> Self: ...
    def __pow__(self, a: int) -> Self: ...
    def __neg__(self) -> Self: ...
    def __int__(self) -> int: ...
    def sqrt(self) -> Self | None: ...
    def is_square(self) -> bool: ...
    def is_even(self) -> bool: ...
    def __eq__(self, a: object) -> bool: ...
    def to_bytes(self) -> bytes: ...

    @classmethod
    def from_int_checked(cls, v: int) -> Self: ...

    @classmethod
    def from_int_wrapping(cls, v: int) -> Self: ...

    @classmethod
    def from_bytes_checked(cls, b: bytes) -> Self: ...

    @classmethod
    def from_bytes_wrapping(cls, b: bytes) -> Self: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class FE(APrimeFE):
    SIZE: int

    def sqrt(self) -> Self | None: ...


class Scalar(APrimeFE):
    SIZE: int

    @classmethod
    def from_int_nonzero_checked(cls, v: int) -> Self: ...

    @classmethod
    def from_bytes_nonzero_checked(cls, b: bytes) -> Self: ...


class GE:
    ORDER: int
    ORDER_HALF: int

    @property
    def infinity(self) -> bool: ...

    @property
    def x(self) -> FE: ...

    @property
    def y(self) -> FE: ...

    def __init__(self, x: int | FE | None = None, y: int | FE | None = None) -> None: ...
    def __add__(self, a: GE) -> GE: ...

    @staticmethod
    def sum(*ps: GE) -> GE: ...

    @staticmethod
    def batch_mul(*aps: tuple[int | Scalar, GE]) -> GE: ...

    def __rmul__(self, a: int | Scalar) -> GE: ...
    def __neg__(self) -> GE: ...
    def __sub__(self, a: GE) -> GE: ...
    def __eq__(self, a: object) -> bool: ...
    def has_even_y(self) -> bool: ...
    def to_bytes_compressed(self) -> bytes: ...
    def to_bytes_compressed_with_infinity(self) -> bytes: ...
    def to_bytes_uncompressed(self) -> bytes: ...
    def to_bytes_xonly(self) -> bytes: ...

    @staticmethod
    def lift_x(x: int | FE) -> GE: ...

    @staticmethod
    def from_bytes_compressed(b: bytes) -> GE: ...

    @staticmethod
    def from_bytes_compressed_with_infinity(b: bytes) -> GE: ...

    @staticmethod
    def from_bytes_uncompressed(b: bytes) -> GE: ...

    @staticmethod
    def from_bytes(b: bytes) -> GE: ...

    @staticmethod
    def from_bytes_xonly(b: bytes) -> GE: ...

    @staticmethod
    def is_valid_x(x: int | FE) -> bool: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...


G: GE


class FastGEMul:
    table: list[GE]

    def __init__(self, p: GE) -> None: ...
    def mul(self, a: int | Scalar) -> GE: ...


FAST_G: FastGEMul
